# manta-rabbit-node-lib

This is an abstraction making it easy to communicate with our rabbitmq servers.

## Installation

npm install manta-rabbit-node-lib

## Synopsis

The simplest possible interface to create and send a MantaEvent

```javascript

var Emitter = require('manta-rabbit-node-lib');
var sender = new Emitter(
		{ exchange: "MantaEventTransitional"
		, routingKey: "testing"
		} );

// simple form, send eventType and payload as hash
var ack = function () { console.warn("did emit"); }
sender.envelope
	( { eventType: 'QueryTimer', payload: {md5: '...', milliseconds:123456 }, actor: { id: 'dog', type:'canine'} }
	, function (mantaevent) { mantaevent.emit(); ack(); } 
	);

// also can specify payload separately.
var ack = function () { console.warn("did emit"); }
sender.message
	( 'QueryTimer'
	, { md5: '...', milliseconds: 123456 }
	, function (message) {
			sender.envelope
				( { payload: message, actor: { id: 'dog', type:'canine'} }
				, function (mantaevent) {
						mantaevent.emit();
						ack();
					}
				);
		}
	);


```

## Synopsis

This uses the event based interface, allowing you to dynamically add queues and exchanges as needed 

```javascript
var Rabbit = require('manta-rabbit-node-lib/lib/RabbitMQ');

// basic operation
var rabbit = new Rabbit( { connection: { options: { url: 'amqp://user@pass@localhost:5672/' } } } );

rabbit.on('ready', function (rabbit) {
		rabbit.exchange( { name: 'MyEventExchange' } );
	} );

rabbit.on('exchangeReady', function (exchange) {
	rabbit.queue( 
		{ name: 'MyQueueName'
		, bindings: [ { routing_key: 'key', exchange: 'MyEventExchange' } ]
		} );
	} );

rabbit.on('queueReady', function (queue) {
		rabbit.emit('MyEventExchange', 'rkey', {a:"This is a message"});
	} );

rabbit.on('MyQueueName', function (message, headers, deliveryInfo) { 
		console.log(deliveryInfo.routing_key + '> ' + message.a) 
		rabbit.allDone();
	} );

```

would output:

rkey> This is a message

The supplied deliveryInfo looks like this:

```javascript
{ contentType: 'application/json'
, queue: 'MyQueueName'
, deliveryTag: 1
, redelivered: false
, exchange: 'MyEventExchange'
, routingKey: 'key'
, consumerTag: 'node-amqp-30383-0.9582679294981062' 
}
```

## Details

Example with every possible option enumerated

```javascript

var rabbit = new Rabbit(
	{ connection:
		{ options: 
			{ url: 'amqp://user@pass@localhost:5672/' // OR the below options
			, host: 'localhost'
			, port: 5672
			, login: 'user'
			, password: 'pass'
			, vhost: '/'
			}
		, implOptions: 
			{ defaultExchangeName: 'myDefault'
			, routingKeyInPayload: false
			, deliveryTagInPayload: false
			, reconnect: true
			, reconnectBackoffStrategy: ['linear','exponential'][0]
			, reconnectExponentialLimit: 120000 // ms
			, reconnectBackoffTime: 1000 // ms
			}
		}
	, exchanges:
		[ { name: 'MyEventExchange'
			, type: ['direct','fanout','topic'][2]
			, passive: false
			, durable: false
			, autoDelete: false
			, confirm: false // ack|error event on publish OR callback called
			}
		]
	, queues:
		[ { name: 'MyQueueName'
			, bindings:
				[ { routing_key: 'ARoutingKey'
					, exchange: 'AnExchange'
					}
				, { routing_key: 'AnotherKey'
					, exchange: 'AnExchange'
					}
				, { routing_key: 'AnotherKey'
					, exchange: 'OtherExchange'
					}
				]
			, passive: false
			, durable: false
			, exclusive: false
			, autoDelete: true
			, noDeclare: false
			, arguments: { } // additional arguments for create?
			, closeChannelOnUnsubscribe: false
			, subscribeOptions:
				{ ack: false // as fast as they come in 
										// - call queue.shift in listenCallback to enable 
										// next delivery if true
				, prefetchCount: 1 // how many to get before an ack is sent (0 unlimited)
				, 
				}
			, listenCallback: 
				function (message, headers, deliveryInfo, queue, rabbit) { 
					// message - the message received
					// headers - hash of the headers of the message
					// deliveryInfo - hash of delivery information indicated above
					// queue - the queue object - use for .shift() in ack:true mode
					// rabbit - our object, in case you want to emit on it
					// Do something with the received messages here
				}
			}
		]
	} , function (error, rabbit) {
			rabbit.emit 
				( 'MyEventExchange'
				, "myRoutingKey"
				, { message: "here" }
				, { mandatory: false
					, immediate: false
					, contentType: 'application/octet-stream'
					, contentEncoding: null
					, headers: { header: "value" }
					, deliveryMode: {nonpersistant:1,persistant:2}.nonpersistant
					, priority: 5 // 0-9
					, replyTo: 'myReplyQueue'
					}
				, function (booleanError) {
		  			// called when exchange in confirm mode
					}
				);
	} );

```
