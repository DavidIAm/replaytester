var express = require('express')
	, util = require('util')
	, http = require('http')
	, amqp = require('amqp')
	, Config = require('./config_getter.js')
	, http = require('http')
  , uuid = require('node-uuid')
  , uuider = require('node-uuid')
	;

var config = new Config;
var conn = amqp.createConnection({url:'amqp://localhost'});
var events = {};


listOfValues = function (object, sortfunc) {
	var values = [];
	var keys = Object.keys(object).sort(sortfunc);
	for (var k in keys) {
		values.push(object[keys[k]]);
	}
	return values;
};

var with_statstruct = function (cb) {
	console.warn("still waiting for statistics event while in default mode");
	setTimeout(cb, 500);
};


config.addListener
	( 'statistics'
	, function (statdata) {
console.log("got statistics event.  Collect data for time spanning " + statdata.collectFor + "ms, Poll on Interval " + statdata.pollInterval + 'ms, tend on interval ' + statdata.tendInterval + 'ms, listen on port ' + statdata.httpPort);

			var monitor = express();
			monitor.configure( function () {
  			monitor.set('port', statdata.httpPort);
  			monitor.set('views', __dirname + '/views');
  			monitor.set('view engine', 'jade');
  			monitor.use(express.favicon());
  			monitor.use(express.logger('dev'));
  			monitor.use(express.bodyParser());
  			monitor.use(express.methodOverride());
  			monitor.use(monitor.router);
			} );
			monitor.configure('development', function(){
  			monitor.use(express.errorHandler());
			});
			http.createServer(monitor).listen
				( monitor.get('port')
				, function() {
						console.log("Express server listening on port " + monitor.get('port'));
					}
				);


			with_statstruct = function (cb) {
				cb(
					{ now: new Date().getTime()
					, statWindow: statdata['collectFor']
					, events: 
							listOfValues(events, function (a,b) { 
								return a.send - b.send 
							} )
							.filter( function (a) { 
								return a.send && (a.receive || a.error) 
							} )
					, pollInterval: statdata.pollInterval
					, tendInterval: statdata.tendInterval
					});
			};

			var numKeys = parseInt(statdata.collectFor / statdata.pollInterval);
			setInterval( function () {
				var time = new Date().getTime();
				// tend by removing the data that is too old to care about
				var categorized = {};
				for (var i in events) {
					if (typeof categorized[events[i].exchange] == "undefined")
						categorized[events[i].exchange] = [];
					categorized[events[i].exchange].push( i );
				}
				for (var categoryKey in categorized) {
					var sortkeys = 
						categorized[categoryKey]
							.sort( function (a, b) {
								return events[a].send - events[b].send }
							);
					while (sortkeys.length > numKeys) {
						delete events[sortkeys.pop()];
					}
				}
			}, statdata.tendInterval);

			monitor.get
				( '/status'
				, function(req, res) {
						with_statstruct( function (data) {
							res.status(200).send(data);
						} );
					}
				);
		}
	);

config.addListener
	( 'exchange'
	, function(exchdef) {
			conn.exchange
				( exchdef.name
				, { type: exchdef.type
					, passive: exchdef.passive
					, durable: exchdef.durable
					, autoDelete: exchdef.auto_delete
					}
				, function ( exchange ) {
				console.log("exchange " + exchdef.name);
						conn.queue
							( 'watchdog'
							, { passive: false
								, durable: false
								, exclusive: false
								, autoDelete: true
								}
							, function ( queue ) {
				console.log("queue " + exchdef.name);
									queue.subscribe
										( function ( message, headers, deliveryInfo ) {
												if (message.eventType == 'Heartbeat') {
													var payload = JSON.parse(message.payload);
													if (payload.receive) {
													} else {
														var receive = new Date().getTime();
														var delay = receive - message.eventEffectiveTime;
														events[message.uuid] = {send:message.eventEffectiveTime,receive:receive,delay:delay,exchange:exchdef.name,uuid:message.uuid};
														exchange.publish
															( 'heartbeat'
															, { eventEffectiveTime: message.send
																, eventGroup: 'heartbeat'
																, sourceIdentity: { id: '1B' , type: 'system' }
																, actor: { id: '1B' , type: 'system' }
																, eventType: 'Heartbeat'
																, payload: JSON.stringify(events[message.uuid])
																, context: 'heartbeat monitor'
																, process: process.pid
																, uuid: uuider.v4()
																, eventTimestamp: new Date().getTime()
																}
															, { mandatory: true // to queue
																, immediate: true // to consumer
																, contentType: 'application/json'
																}
															);

													}
												}
											}
										);
				console.log("bind queue " + exchdef.name);
									queue.bind(exchdef.name, '#');
								}
							);
						
						with_statstruct( function (statdata) {
							setInterval( function () {
								var time = new Date().getTime();
								var paypay = JSON.stringify({send:time});
								var payloadObj = 
									{ eventEffectiveTime: time
									, eventGroup: 'heartbeat'
									, sourceIdentity: { id: '1A' , type: 'system' }
									, actor: { id: '1A' , type: 'system' }
									, eventType: 'Heartbeat'
									, payload: paypay
									, context: 'heartbeat monitor'
									, process: process.pid
									, uuid: uuider.v4()
									}
								var payload = JSON.stringify(payloadObj);
								var req = http.request
									( { port: 8240
										, method: 'POST'
										, path: '/'+exchdef.name
										, headers:
											{ 'content-type': 'application/json'
											, 'connection': 'keep-alive'
											, 'accept': '*/json'
											, 'content-length': payload.length
											}
										}
									, function ( res ) {
											var buf = '';
											res.on('data', function ( chunk ) {
												buf = buf + chunk;
												});
											res.on('end', function ( ) {
													var darray = [];
													try {
														darray = JSON.parse(buf);
													} catch (e) {
														darray = [ { error: e } ]
													}
													for (var j in darray) {
														var data = darray[j];
														events[data.uuid] = { send: time, exchange: exchdef.name, uuid:data.uuid };
													}
												});
									  }
									);
								req.on('error', function (error) {
									console.log("exception.  Recording " + payloadObj.uuid + " for " + error);
									events[payloadObj.uuid] = { time: time, exchange: exchdef.name, uuid:payloadObj.uuid, error: error };
								});
								req.write(payload);
								req.end();

/*
								exchange.publish
								( 'heartbeat'
								, { send: new Date().getTime() }
								, { mandatory: true // to queue
									, immediate: true // to consumer
									, contentType: 'application/json'
									}
								);
*/
							}, statdata.pollInterval );
						});
					}
				)
			}
		);

conn.on('ready', function () {
	config.readFile('config.json');
})

