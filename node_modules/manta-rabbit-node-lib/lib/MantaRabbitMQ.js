var amqp = require('amqp');
var async = require('async');
var util = require('util')
	, events = require('events');

function Rabbit (config, readycallback) {
	events.EventEmitter.call(this);
	this.refCount = 0;
	var self = this;
	this.exchanges = [];
	this.queues = [];
	
	process.nextTick( function () { self.connect(config, readycallback); } );
}

util.inherits(Rabbit, events.EventEmitter);

Rabbit.prototype.connect = function (config, readycallback) {
	var self = this;
	this.connection = amqp.createConnection(config.connection, { heartbeat: 1 });
	if (readycallback) this.on('ready', function(me) {
			readycallback(null, me); 
		} );

	this.connection.on('error', function (e) { 
			console.log("ERROR:",e);
		self.emit('error', self.exchanges, self.queues, e );
		process.nextTick(function () {
			self.exchange = []; // stop pointing to the old array
			self.queues= [];    // stop pointing to the old array
		});
	} );
	this.connection.on('close', function (e) {
			self.emit('close', self.exchanges, self.queues, e ) } );

	this.on('allDone', function () { 
			self.connection.end(); } );
	this.connection.on('ready', function () {
			self.on('Rabbit_Declare_Exchange', function (exchdef, callback) { 
				self.exchange(exchdef, callback); } );
			self.on('Rabbit_Declare_Queue', function (queuedef, callback) { 
				self.queue(queuedef, callback); } );
			// first the exchanges, then the queues!
			async.series(
					[ function (sercb) {
							if (config.exchanges) {
								async.map( config.exchanges, function (exchdef, mapcb) {
										self.emit('Rabbit_Declare_Exchange', exchdef, mapcb);
									}, function (error, results) {
										if (error) return sercb(error);
										sercb(null, results);
									} );
							} else {
								sercb();
							}
						}
					, function (sercb) {
							if (config.queues) {
								async.map( config.queues, function (queuedef, mapcb) {
										self.emit('Rabbit_Declare_Queue', queuedef, mapcb);
									}, function (error, results) {
										if (error) return sercb(error);
										sercb(null, results);
									} );
							} else {
								sercb();
							}
						}
					], function (error, results) {
						if (error) console.log("RABBIT ERROR CALLBACK", error);
						if (readycallback && error) return readycallback(error);
						if (error) throw error;
						self.emit('ready', self);
					}
				);
		} );
}

Rabbit.prototype.queue = function (queuedef, queueDoneCallback) {
	var self = this;
	this.connection.queue
		( queuedef.name
		, { passive: queuedef.passive
			, durable: queuedef.durable
			, exclusive: queuedef.exclusive
			, autoDelete: queuedef.autoDelete
			, noDeclare: queuedef.noDeclare
			, arguments: queuedef.arguments
			, closeChannelOnUnsubscribe: queuedef.closeChannelOnUnsubscribe
			}
		, function ( queue ) {
				self.queues[queuedef.name] = [ queue, queuedef ];
				self.on('Rabbit_Subscribe_'+queuedef.name, function (options, cb) {
						queue.subscribe
							( options
							, function (message, headers, deliveryInfo) {
									if (cb) {
										return cb
											( message
											, headers
											, deliveryInfo
											, queue
											, self
											);
									}
									return self.emit
										( queue.name
										, message
										, headers
										, deliveryInfo
										, queue
										);
								}
							);
					} );
				self.on('Rabbit_Bind_'+queuedef.name, function (exchange, routingKey, cb) {
						self.on('Rabbit_Unbind_'+queue.name, function (exchange, routingKey) {
							queue.unbind(exchange, routingKey);
						});
						queue.bind(exchange, routingKey, function (queue) {
							if (cb) cb(null, queue);
						});
					} );
				async.forEachSeries( queuedef.bindings
					, function (bindspec, mapcb) {
							self.emit('Rabbit_Bind_'+queuedef.name, bindspec.exchange, bindspec.routingKey, mapcb );
						}
					, function (error, collection) {
							if (error && queueDoneCallback) return queueDoneCallback(error);
							if (error) throw error;
							queue.once('basicConsumeOk', function (result, info) {
									if (this.name != queuedef.name) throw "name mismatch:" .JSON.stringify([this.name, queue.name]);
									self.on('Rabbit_UnbindAll_'+queue.name, function () {
											queuedef.bindings.each( function (bind) {
												self.emit('Rabbit_Unbind_'+queue.name, bind.exchange, bind.routingKey );
											} );
											self.emit('Rabbit_UnboundAll_'+queue.name);
										} );
									self.on('Rabbit_Unsubscribe_'+queue.name, function () {
											self.emit('Rabbit_UnbindAll_'+queue.name);
											self.on('Rabbit_UnboundAll_'+queue.name, function () {
												queue.unsubscribe(result.consumerTag).addCallback(function () {
														self.emit('Rabbit_Unsubscribed_', queue.name );
													} );
											} );
										})
									self.emit('queueReady', queue, queuedef );
									if ( queueDoneCallback ) queueDoneCallback(null, queue, queuedef);
								} );
							self.emit('Rabbit_Subscribe_'+queuedef.name, queuedef.subscribeOptions, queuedef.listenCallback );
						}
					);
			}
		);
};

Rabbit.prototype.exchange = function ( exchdef , exchangeDoneCallback ) {
	var self = this;
	this.connection.exchange
		( exchdef.name
		, { type: exchdef.type
			, passive: exchdef.passive
			, durable: exchdef.durable
			, autoDelete: exchdef.auto_delete
			, confirm: exchdef.confirm
			}
		, function (exchange) {
				self.exchanges[exchdef.name] = [ exchange, exchdef ];
				self.emit("exchangeReady", exchange, exchdef);
				// function publish (routingKey, message, options, callback)
				self.on(exchdef.name, function (routingKey, message, options, callback) {
					exchange.publish(routingKey, message, options, callback);
				} );
				if (exchangeDoneCallback) exchangeDoneCallback(null, exchange);
			}
		);	
};

Rabbit.prototype.allDone = function ( ) {
	this.emit('allDone');
};

module.exports = Rabbit;

